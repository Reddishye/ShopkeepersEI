plugins {
    id 'java'
    id("com.gradleup.shadow") version "9.3.1"
    id("com.diffplug.spotless") version "8.2.0"
    id("xyz.jpenilla.run-paper") version "2.3.1"
}

ext.getGitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
        ignoreExitValue = true
    }
    return stdout.toString().trim() ?: "0"
}

ext.buildVersion = version + '+' + getGitHash()
ext.isSnapshot = version.contains('-SNAPSHOT')
ext.pluginVersion = isSnapshot ? buildVersion : version

println 'Project version: ' + version
println 'Build version: ' + buildVersion
println 'Plugin version: ' + pluginVersion

repositories {
    mavenCentral()
    maven {
        name = "spigotmc-repo"
        url = "https://hub.spigotmc.org/nexus/content/repositories/snapshots/"
    }
    maven {
        name = "sonatype"
        url = "https://oss.sonatype.org/content/groups/public/"
    }

    maven {
        url = uri("https://raw.githubusercontent.com/Shopkeepers/Repository/main/releases/")
    }

    maven { url 'https://jitpack.io' }
}

dependencies {
    compileOnly "org.spigotmc:spigot-api:1.20.4-R0.1-SNAPSHOT" // spigot api

    implementation("de.exlll:configlib-paper:4.8.0") // Config
    implementation "com.google.inject:guice:7.0.0" // dependency injection

    // spigot doesn't have adventure by default as paper does, so we need to add it
    // high prob that some of these are redundant/not needed, but whatever
    // todo: check which dependencies are actually needed
    implementation "net.kyori:adventure-text-serializer-plain:4.26.1"
    implementation "net.kyori:adventure-text-serializer-legacy:4.26.1"
    implementation "net.kyori:adventure-platform-bukkit:4.4.1"
    implementation "net.kyori:adventure-text-minimessage:4.26.1"
    implementation "net.kyori:adventure-api:4.26.1"
    implementation 'net.kyori:adventure-text-serializer-ansi:4.26.1' // ANSI Support (cuz logger)

    compileOnly 'com.nisovin.shopkeepers:ShopkeepersAPI:2.25.0'

    compileOnly 'com.github.Ssomar-Developement:SCore:5.25.3.9'
    // to add: ExecutableBlocks, ExecutableEvents, Oraxen, MMOItems

    // Since rc3 the official lamp builds are broken (for older versions as 1.20.4), so we use a jitpack build
    implementation 'com.github.Reddishye.Lamp:lamp.common:6a2f380f00'
    implementation 'com.github.Reddishye.Lamp:lamp.bukkit:6a2f380f00'
    implementation 'com.github.Reddishye.Lamp:lamp.brigadier:6a2f380f00'
}


def targetJavaVersion = 21
java {
    def javaVersion = JavaVersion.toVersion(targetJavaVersion)
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
    if (JavaVersion.current() < javaVersion) {
        toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'

    if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
        options.release.set(targetJavaVersion)
    }
}

shadowJar {
    version = version
    archiveClassifier.set('') // remove the classifier
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    def relocateBase = 'es.redactado.shopkeepersEI.libs'

    relocate 'com.google.inject', "${relocateBase}.guice"
    relocate 'com.google.common', "${relocateBase}.guava"
    relocate 'javax.inject', "${relocateBase}.inject"
    relocate 'aopalliance', "${relocateBase}.aopalliance"

    relocate 'de.exlll.configlib', "${relocateBase}.configlib"

    relocate 'net.kyori.adventure', "${relocateBase}.adventure"
    relocate 'net.kyori.examination', "${relocateBase}.examination"
    relocate 'net.kyori.option', "${relocateBase}.option"

    relocate 'revxrsal.commands', "${relocateBase}.lamp"

    minimize {
        exclude(dependency('com.google.inject:.*'))
    }

    mergeServiceFiles()
}

processResources {
    def props = [
        'pluginVersion': pluginVersion,
        'pluginUrl': pluginUrl,
        'pluginDescription': pluginDescription
    ]
    inputs.properties props
    filteringCharset 'UTF-8'
    filesMatching('plugin.yml') {
        expand props
    }
}

tasks {
    runServer {
        minecraftVersion("1.21.8")
    }
}

spotless {
    def currentBranch = getCurrentGitBranch()
    def mainBranch = getMainBranch()
    
    if (currentBranch != mainBranch && mainBranch != null) {
        println "Spotless: Formatting changes from origin/${mainBranch}"
        ratchetFrom("origin/${mainBranch}")
    } else {
        println "Spotless: Formatting all files"
    }

    format("misc") {
        target(
                "*.gradle.kts",
                ".gitattributes",
                ".gitignore"
        )

        trimTrailingWhitespace()
        endWithNewline()
    }

    java {
        googleJavaFormat("1.26.0").aosp().reflowLongStrings().skipJavadocFormatting()
        formatAnnotations()
        removeUnusedImports()
    }
}

def getCurrentGitBranch() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', '--abbrev-ref', 'HEAD'
            standardOutput = stdout
            ignoreExitValue = true
        }
        return stdout.toString().trim() ?: null
    } catch (Exception e) {
        return null
    }
}

def getMainBranch() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'symbolic-ref', 'refs/remotes/origin/HEAD'
            standardOutput = stdout
            ignoreExitValue = true
        }
        def result = stdout.toString().trim()
        if (result) {
            return result.replaceFirst('refs/remotes/origin/', '')
        }
    } catch (Exception ignored) {}
    
    def branches = ['main', 'master']
    for (branch in branches) {
        if (gitRefExists("origin/${branch}")) {
            return branch
        }
    }
    
    for (branch in branches) {
        if (gitRefExists(branch)) {
            return branch
        }
    }
    
    return null
}

def gitRefExists(String ref) {
    try {
        def result = exec {
            commandLine 'git', 'rev-parse', '--verify', ref
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }
        return result.exitValue == 0
    } catch (Exception e) {
        return false
    }
}
